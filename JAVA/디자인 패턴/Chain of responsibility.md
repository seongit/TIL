복수의 오브젝트(객체)를 사슬(chain)처럼 연결해 두면, 그 오브젝트(객체)의 사슬을 차례로 돌면서 
목적한 오브젝트(객체)를 결정하는 방법

responsibility는 책임이라는 의미이므로 '책임을 떠넘기는' 구조
이 패턴을 사용했을 때의 장점
'요청하는 쪽'과 '처리하는 쪽'의 연결을 유연하게 해서 각 오브젝트를 부품으로 독립시킬 수 있다.
상황에 따라 요청을 처리할 오브젝트가 변하는 프로그랭에도 대응할 수 있다. 

여러 개의 책임들을 동적으로 연결해서 순차적으로 실행하는 패턴
책임이란? 무언가를 처리하는 기능(클래스)이며,
기능을 클래스 별로 분리하여 구현하도록 유도하므로 클래스의 코드가 최적화됨


이 패턴을 사용해야하는 이유
이 패턴을 사용하지 않으면 '이 요구는 이 사람이 처리해야 한다.'라는 정보를 누군가가 중앙집권적으로 가지고 있어야 함
그 정보를 '요구를 하는 사람'에게 갖게 하는 것은 현명한 방법이 아님
요구하는 사람이 처리자들의 역할 분담까지 자세하게 알아야 한다는 부품으로써의 독립성이 훼손되기 때문

이 패턴을 사용했을 때의 단졈
유연성은 높아지지만, 처리가 지연 됨
누가 요구를 처리할 것인지 미리 정해져 있고 그 상대가 바로 처리하는 경우와 비교하면 Chain of Resposibility 패턴을 적용한 처리는 지연될 것이다. 요구와 처리자의 관계가 고정적이고 처리 속도가 중요한 경우에는 Chain of Responsibility 패턴을 사용하지 않는 편이 유효한 경우도 있다.


ex. 
1) URL
책임 1 프로토콜
책임 2 도메인
책임 3 포트

체인처럼 연결되어 순서대로 처리되는 것

2) 신용카드
책임 1 국민카드
책임 2 신한카드
책임 3 삼성카드
책임 4 현대카드

...


## Ref.

https://www.youtube.com/watch?v=FAHEWQD6EVE
